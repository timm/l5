-- keyslib.lua. Misc lua routines.
-- (c)2022, Tim Menzies BSD-2 clause

local l={}

-- ## Linting
local b4={}; for k,v in pairs(_ENV) do b4[k]=v end

-- ## Random number generator
-- The LUA doco says its random number generator is not stable across platforms.
-- Hence, we use our own (using Park-Miller).

local Seed=937162211
function l.srand(n)  --- reset random number seed (defaults to 937162211) 
  Seed = n or 937162211 end

function l.rand(nlo,nhi) --- return float from `nlo`..`nhi` (defaults 0..1)
  nlo, nhi = nlo or 0, nhi or 1
  Seed = (16807 * Seed) % 2147483647
  return nlo + (nhi-nlo) * Seed / 2147483647 end

function l.rint(nlo,nhi)  --- returns integer from `nlo`..`nhi`
  return math.floor(0.5 + l.rand(nlo,nhi)) end

-- ## Lists
function l.ent(t) --- entropy
  local function calc(p) return p*math.log(p) end
  local n=0; for _,n1 in pairs(t) do n=n+n1 end
  local e=0; for _,n1 in pairs(t) do e=e - calc(n1/n) end 
  return e end

function l.kap(t, fun) --- map function `fun`(k,v) over list (skip nil results) 
  local u={}; for k,v in pairs(t)do u[k]=fun(k,v) end; return u end

function l.keys(t) --- sort+return `t`'s keys (ignore things with leading `_`)
  local function want(k,x) if tostring(k):sub(1,1) ~= "_" then return k end end
  return l.sort(l.kap(t,want)) end

function l.last(t) -- return list item in a list
  return t[#t] end

function l.map(t, fun)  --- map function `fun`(v) over list (skip nil results) 
  local u={}; for i,v in pairs(t)do u[1+#u]=fun(v) end;return u end

function l.push(t, x) --- push `x` to end of list; return `x` 
  table.insert(t,x); return x end

function l.sd(t) --- sorted list standard deviation= (90-10)th percentile/2.58
  return (t[(.9*#t)//1] - t[(.1*#t)//1]) / 2.58 end

-- ### Sorting Lists
function l.sort(t, fun) --- return `t`,  sorted by `fun` (default= `<`)
  table.sort(t,fun); return t end

-- ## Things to Strings
function l.fmt(sControl,...) --- emulate printf
  return string.format(sControl,...) end

function l.oo(t)  --- print `t`'s string (the one generated by `o`)
  print(l.o(t)) end

function l.o(t) --- table to string (recursive)
  if type(t) ~= "table" then return tostring(t) end
  local function filter(v) return fmt(":%s %s",v,l.o(t[v])) end
  t = #t>0 and l.map(t,tostring) or l.map(l.keys(t),filter)
  return (t._is or "").."{".. table.concat(t," ") .."}" end

-- ### Strings to Things
function l.coerce(s) --- return int or float or bool or string from `s`
  local function fun(s1)
    if s1=="true"  then return true  end
    if s1=="false" then return false end
    return s1 end
  return math.tointeger(s) or tonumber(s) or fun(s:match"^%s*(.-)%s*$") end

function l.options(s,    t) --- parse help string to extract a table of options
  t={}; s:gsub("\n [-][%S]+[%s]+[-][-]([%S]+)[^\n]+= ([%S]+)",
                 function(k,v) t[k]=l.coerce(v) end)
  t._help = s
  return t end

function csv(sFilename,fun) --- call `fun` on rows (after coercing cell text)
  local src,s,t  = io.input(sFilename)
  while true do
    s = io.read()
    if   s
    then t={}; for s1 in s:gmatch("([^,]+)") do t[1+#t]=l.coerce(s1) end; fun(t)
    else return io.close(src) end end end

-- ## Objects
function l.obj(s,    t,i,new) --- Create a klass and a constructor + print method
  local isa=setmetatable
  function new(k,...) i=isa({},k); return isa(t.new(i,...) or i,k) end
  t={__tostring = function(x) return l.o(x) end}
  t.__index = t;return isa(t,{_is=s,__call=new}) end

-- That's all folks.
return l
